#include "LambdaSenders.h"
#include "RequestHandler.h"
#include "ModuleRegistry.h"
#include "FileCache.h"
#include "macros.h"
#include "Session.h"

#include "DatabaseModule.h"
#include "ApiProcessor.h"

#include <boost/asio/ip/tcp.hpp>
#include <boost/thread.hpp>
#include <boost/make_shared.hpp>
#include <boost/program_options.hpp>

#include <iostream>
#include <memory>
#include <fstream>
#include <sstream>

void printConnectionInfo(tcp::socket& socket) {
    try {
        tcp::endpoint remote_ep = socket.remote_endpoint();
        boost::asio::ip::address client_address = remote_ep.address();
        unsigned short client_port = remote_ep.port();

        std::cout << "Client connected from: "
            << client_address.to_string()
            << ":" << client_port << std::endl;
    }
    catch (const boost::system::system_error& e) {
        std::cerr << "Error getting connection info: " << e.what() << std::endl;
    }
}

void CreateAPIHandlers(RequestHandler* module, ApiProcessor* apiProcessor) {
    // Основной эндпоинт для всех данных — как ожидает фронт
    module->addRouteHandler("/api/all-data", [apiProcessor](const sRequest& req, sResponce& res) {
        apiProcessor->handleGetAllData(req, res);
        });

    // Список сотрудников (можно оставить как есть, но лучше сделать отдельный обработчик позже)
    module->addRouteHandler("/api/employees", [apiProcessor](const sRequest& req, sResponce& res) {
        if (req.method() == http::verb::post) {
            apiProcessor->handleAddEmployee(req, res);
        }
        else if (req.method() == http::verb::get) {
            apiProcessor->handleGetAllData(req, res); // временно ок — фронт пока не использует отдельно
        }
        else {
            res.result(http::status::method_not_allowed);
        }
        });

    // Исправляем регулярку — добавляем опциональный слеш в конце
    module->addRouteHandler("/api/employees/\\d+(?:/)?", [apiProcessor](const sRequest& req, sResponce& res) {
        if (req.method() == http::verb::put) {
            apiProcessor->handleUpdateEmployee(req, res);
        }
        else {
            res.result(http::status::method_not_allowed);
        }
        });

    module->addRouteHandler("/api/hours/\\d+", [apiProcessor](const sRequest& req, sResponce& res) {
        if (req.method() == http::verb::post) {
            apiProcessor->handleAddHours(req, res);
        }
        else {
            res.result(http::status::method_not_allowed);
        }
        });

    // Исправляем пути для штрафов и премий — приводим к тому, что ожидает фронт
    module->addRouteHandler("/api/employees/\\d+/penalties", [apiProcessor](const sRequest& req, sResponce& res) {
        if (req.method() == http::verb::post) {
            apiProcessor->handleAddPenalty(req, res);
        }
        else {
            res.result(http::status::method_not_allowed);
        }
        });

    module->addRouteHandler("/api/employees/\\d+/bonuses", [apiProcessor](const sRequest& req, sResponce& res) {
        if (req.method() == http::verb::post) {
            apiProcessor->handleAddBonus(req, res);
        }
        else {
            res.result(http::status::method_not_allowed);
        }
        });
}

void CreateNewHandlers(RequestHandler* module, std::string staticFolder) {
    module->addRouteHandler("/test", [](const sRequest& req, sResponce& res) {
        if (req.method() != http::verb::get) {
            res.result(http::status::method_not_allowed);
            res.set(http::field::content_type, "text/plain");
            res.body() = "Method Not Allowed. Use GET.";
            return;
        }
        res.set(http::field::content_type, "text/plain");
        res.body() = "RequestHandler Module Scaling Test.\nAlso checking support for the Russian language.";
        res.result(http::status::ok);
        });

    module->addRouteHandler("/*", [](const sRequest& req, sResponce& res) {});
}

int main(int argc, char* argv[]) {
    // Объявление переменных для параметров
    std::string address;
    int port;
    std::string directory;

    // Настройка парсера аргументов
    po::options_description desc("Available options");
    desc.add_options()
        ("help,h", "Show help")
        ("address,a", po::value<std::string>(&address)->default_value("0.0.0.0"),
            "IP address to listen on")
        ("port,p", po::value<int>(&port)->default_value(8080),
            "Port to listen on")
        ("directory,d", po::value<std::string>(&directory)->default_value("static"),
            "Path to static files");

    po::variables_map vm;
    try {
        po::store(po::parse_command_line(argc, argv, desc), vm);
        po::notify(vm);

        if (vm.count("help")) {
            std::cout << desc << "\n";
            return 0;
        }

        if (port <= 0 || port > 65535) {
            std::cerr << "Error: port must be in the range 1-65535\n";
            return EXIT_FAILURE;
        }

        // Проверка существования директории
        if (!fs::exists(directory)) {
            std::cerr << "Warning: directory '" << directory << "' does not exist\n";
        }
    }
    catch (const po::error& e) {
        std::cerr << "Argument parsing error: " << e.what() << "\n";
        std::cerr << desc << "\n";
        return EXIT_FAILURE;
    }
    std::cout << "Console CP: " << GetConsoleCP() << std::endl;
    std::cout << "Console Output CP: " << GetConsoleOutputCP() << std::endl;
    std::cout << "ACP: " << GetACP() << std::endl;
    std::cout << "OEMCP: " << GetOEMCP() << std::endl;

    // Вывод конфигурации
    std::cout << "Server configuration:\n"
        << " Address: " << address << "\n"
        << " Port: " << port << "\n"
        << " Directory: " << directory << "\n\n";
//////////////////////////////////////////////////////////
    net::io_context ioc;

    const char* databaseStr = "dbname=postgres user=postgres password=postgres host=127.0.0.1 port=54855";//TODO: Перенести хардкод в параметры

    ModuleRegistry registry;
    auto* cacheModule = registry.registerModule<FileCache>(directory.c_str(), true, 100);
    auto* requestModule = registry.registerModule<RequestHandler>();
    auto* dbModule = registry.registerModule<DatabaseModule>(ioc, databaseStr);

    ApiProcessor apiProcessor(dbModule); //TODO: Не совсем подходит моей идеологии управления жизнью через реестр модулей. Однако это по сути обёртка

    CreateAPIHandlers(requestModule, &apiProcessor);

    CreateNewHandlers(requestModule, directory);

    registry.initializeAll();

    static_cast<RequestHandler*>(requestModule)->setFileCache(cacheModule);


///////////////////////////////////////////////////////////

    try {
        auto const net_address = net::ip::make_address(address);
        auto const net_port = static_cast<unsigned short>(port);
        tcp::acceptor acceptor{ ioc, {net_address, net_port} };
        std::cout << "Server started on http://" << address << ":" << port << std::endl;

        // UPDATED: Do_accept с std::function для safe recursive (avoid self-ref UB)
        std::function<void()> do_accept_func = [&acceptor, &ioc, requestModule, &do_accept_func]() {  // NEW: Explicit function, self-capture by ref
            auto socket = std::make_shared<tcp::socket>(ioc);
            acceptor.async_accept(*socket,
                [socket_ptr = socket, &do_accept_func, requestModule](beast::error_code ec) {
                    if (!ec) {
                        printConnectionInfo(*socket_ptr);
                        std::make_shared<session>(std::move(*socket_ptr), requestModule)->run();
                    }
                    else {
                        std::cerr << "Accept error: " << ec.message() << std::endl;
                    }
                    do_accept_func();  // Рекурсия via function call (safe)
                });
            };

        do_accept_func();
        ioc.run();  // Блокирует, обрабатывает все async
    }
    catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return EXIT_FAILURE;
    }
    return 0;
}